/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */

/*
 * Copyright (c) 2014, Joyent, Inc.
 */

var fs = require('fs');
var util = require('util');
var test = require('tape').test;

var common = require('./common');
var uuid = common.uuid;



// --- Globals

var clients, client, server;
var keyName = uuid();
var machine;
var KEY = 'ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAIEAvad19ePSDckmgmo6Unqmd8' +
    'n2G7o1794VN3FazVhV09yooXIuUhA+7OmT7ChiHueayxSubgL2MrO/HvvF/GGVUs/t3e0u4' +
    '5YwRC51EVhyDuqthVJWjKrYxgDMbHru8fc1oV51l0bKdmvmJWbA/VyeJvstoX+eiSGT3Jge' +
    'egSMVtc= mark@foo.local';

var TAG_KEY = 'role';
var TAG_VAL = 'unitTest';

var TAG_TWO_KEY = 'smartdc_type';
var TAG_TWO_VAL = 'none';

var META_KEY = 'foo';
var META_VAL = 'bar';

var META_CREDS = [
    {
        username: 'root',
        password: 'secret'
    },
    {
        username: 'admin',
        password: 'secret'
    }
];


// --- Helpers


function checkMachine(t, m) {
    t.ok(m, 'checkMachine ok');
    t.ok(m.id, 'checkMachine id ok');
    t.ok(m.name, 'checkMachine name ok');
    t.ok(m.type, 'checkMachine type ok');
    t.ok(m.state, 'checkMachine state ok');
    t.ok(m.dataset, 'checkMachine dataset ok');
    t.ok(m.ips, 'checkMachine ips ok');
    t.ok(m.memory, 'checkMachine memory ok');
    t.ok(m.metadata, 'checkMachine metadata ok');
    // TODO:
    // Intentionally making disk, which is zero first, and created/updated,
    // which are not set at the beginning, fail until we decide how to proceed
    // t.ok(m.disk, 'checkMachine disk ok');
    // t.ok(m.created, 'checkMachine created ok');
    // t.ok(m.updated, 'checkMachine updated ok');
    t.ok(typeof (m.disk) !== 'undefined');
    t.ok(typeof (m.created) !== 'undefined');
    t.ok(typeof (m.updated) !== 'undefined');
}


function checkSnapshot(t, snap) {
    t.ok(snap);
    t.ok(snap.name);
    t.ok(snap.state);
}


// We cannot test vms provisioning neither status changes without querying
// jobs execution directly. Former approach of checking vms status changes
// assumes that jobs which may cause machine status changes will always
// succeed, which is not the case.
function checkJob(id, callback) {
    return client.vmapi.getJob(id, function (err, job) {
        if (err) {
            return callback(err);
        }

        if (job.execution === 'failed' ||Â job.execution === 'canceled') {
            return callback(new Error('Job failed'));
        }

        return callback(null, (job ? job.execution === 'succeeded' : false));
    });
}


function waitForJob(id, callback) {
    // console.log('waiting for job with uuid: %s', uuid);
    return checkJob(id, function (err, ready) {
        if (err) {
            return callback(err);
        }
        if (!ready) {
            return setTimeout(function () {
                waitForJob(id, callback);
            }, (process.env.POLL_INTERVAL || 500));
        }
        return callback(null);
    });
}

var cfg = common.getCfg();
var DC_NAME = Object.keys(cfg.datacenters)[0];


function createLimit(t, cb) {
    return client.ufds.getUser(client.login, function (err, user) {
        t.ifError(err, 'client.getUser error');

        var limit = {
            datacenter: DC_NAME,
            dataset: 'smartos',
            os: 'smartos',
            check: 'os',
            by: 'machines',
            value: 1
        };
        return user.addLimit(limit, function (er2, limits) {
            t.ifError(er2, 'createLimit error');
            return cb();
        });
    });
}



function saveKey(t, cb) {
    return client.post('/my/keys', {
        key: KEY,
        name: keyName
    }, function (err2, req, res, body) {
        t.ifError(err2, 'POST /my/keys error');
        return cb();
    });
}


// --- Tests


test('setup', function (t) {
    common.setup(function (_, _clients, _server) {
        clients = _clients;
        server  = _server;

        client = clients.user;

        saveKey(t, function () {
            createLimit(t, function () {
                t.end();
            });
        });
    });
});


test('CreateMachine', function (t) {
    var obj = {
        dataset: 'smartos',
        'package': 'sdc_128',
        name: 'a' + uuid().substr(0, 7)
    };
    obj['metadata.' + META_KEY] = META_VAL;
    obj['tag.' + TAG_KEY] = TAG_VAL;

    client.post('/my/machines', obj, function (err, req, res, body) {
        t.ifError(err, 'POST /my/machines error');
        t.equal(res.statusCode, 201, 'POST /my/machines status');
        common.checkHeaders(t, res.headers);
        t.ok(body, 'POST /my/machines body');
        checkMachine(t, body);
        machine = body.id;
        // Handy to output this to stdout in order to poke around COAL:
        console.log("Requested provision of machine: %s", machine);
        t.end();
    });
});


test('Wait For Running', function (t) {
    client.vmapi.listJobs({
        vm_uuid: machine,
        task: 'provision'
    }, function (err, jobs) {
        t.ifError(err, 'list jobs error');
        t.ok(jobs, 'list jobs ok');
        t.ok(jobs.length, 'list jobs is an array');
        waitForJob(jobs[0].uuid, function (err2) {
            t.ifError(err2, 'Check state error');
            if (err2) {
                console.log(util.inspect(err2, false, 8));
            }
            t.end();
        });
    });
});


// --- The resize stuff:
/*
var RESIZE_ATTEMPTS = 5;
var packages = [];
var i;
for (i = 0; i <= RESIZE_ATTEMPTS; i += 1) {
    var newUuid = uuid();

    // May or not be created by previous test run or whatever else:
    packages[i] = {
        uuid: newUuid,
        name: 'sdc_256',
        version: i + '.0.0',
        max_physical_memory: 256,
        quota: 10240,
        max_swap: 512,
        cpu_cap: 150,
        max_lwps: 1000,
        zfs_io_priority: 10 + i,
        'default': false,
        vcpus: 1,
        active: true
    };
};



test('The resize tests', function (t) {
    var finished = 0;
    packages.forEach(function (pack) {
        var pkg_entry;
        // We may have been created this on previous test suite runs or not:
        t.test('Prepare resize package', function (t) {
            console.log(util.inspect(pack, false, 8));
            client.papi.get(pack.uuid, function (err, pkg) {
                if (err) {
                    if (err.restCode === 'ResourceNotFound') {
                        // Try to create:
                        client.papi.add(pack, function (err2, pkg2) {
                            t.ifError(err2, 'Error creating package');
                            t.ok(pkg2);
                            pkg_entry = pkg2;
                            t.end();
                        });
                    } else {
                        t.ifError(err, 'Error fetching package');
                        t.end();
                    }
                } else {
                    pkg_entry = pkg;
                    t.end();
                }
            })
        });


        t.test('Resize Machine', function (t) {
            t.ok(pkg_entry, 'Resize package OK');
            console.log('Resizing to package: %j', pkg_entry);
            client.post('/my/machines/' + machine, {
                action: 'resize',
                'package': pkg_entry.name
            }, function (err) {
                t.ifError(err, 'Resize machine error');
                t.end();
            });
        });


        t.test('Wait For Resized', function (t) {
            console.log('Finished jobs: %d', finished);
            client.vmapi.listJobs({
                vm_uuid: machine,
                task: 'update'
            }, function (err, jobs) {
                t.ifError(err, 'list jobs error');
                t.ok(jobs, 'list jobs OK');
                t.ok(jobs.length, 'update jobs is array');
                var resize_jobs = jobs.filter(function (job) {
                    return (typeof (job.params.max_physical_memory) !== 'undefined');
                });
                t.ok(resize_jobs.length, 'resize jobs is an array');
                console.log('Resize job: %j', resize_jobs[finished]);
                if (typeof (resize_jobs[finished]) !== 'undefined') {
                    waitForJob(resize_jobs[finished].uuid, function (err2) {
                        t.ifError(err2, 'Check state error');
                        finished += 1;
                        console.log('Finished job # %d', finished);
                        t.end();
                    });
                } else {
                    t.end();
                }
            });
        });

    });

    function finishIfDone() {
        if (finished === RESIZE_ATTEMPTS) {
            t.end();
        } else {
            setTimeout(finishIfDone, 1000);
        }
    }

    finishIfDone();
});

*/

test('CreateMachine fails due to limit', function (t) {
    var obj = {
        dataset: 'smartos',
        'package': 'sdc_128',
        name: 'a' + uuid().substr(0, 7)
    };
    obj['metadata.' + META_KEY] = META_VAL;
    obj['tag.' + TAG_KEY] = TAG_VAL;

    client.post('/my/machines', obj, function (err, req, res, body) {
        //t.ok(err, 'Limit failure err');
        console.log(util.inspect(err, false, 8));
        console.log(util.inspect(body, false, 8));
        //t.equal(res.statusCode, 403, 'POST /my/machines status');
        t.end();
    });
});


test('DeleteMachine', function (t) {
    client.del('/my/machines/' + machine, function (err, req, res) {
        t.ifError(err, 'DELETE /my/machines error');
        t.equal(res.statusCode, 204, 'DELETE /my/machines status');
        common.checkHeaders(t, res.headers);
        t.end();
    });
});


test('Wait For Destroyed', function (t) {
    client.vmapi.listJobs({
        vm_uuid: machine,
        task: 'destroy'
    }, function (err, jobs) {
        t.ifError(err, 'list jobs error');
        t.ok(jobs);
        t.ok(jobs.length);
        waitForJob(jobs[0].uuid, function (err2) {
            t.ifError(err2, 'Check state error');
            t.end();
        });
    });
});

test('teardown', function (t) {
    client.del('/my/keys/' + keyName, function (err, req, res) {
        t.ifError(err, 'delete key error');
        t.equal(res.statusCode, 204);

        common.teardown(clients, server, function () {
            t.end();
        });
    });
});
